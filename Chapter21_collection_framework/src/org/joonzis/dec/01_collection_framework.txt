1.1 컬렉션 프레임워크 (Collection Framework)
 - 데이터를 다루기 위한 표준화된 구조  (모든 프레임 워크는 제네릭 타입이 자동으로 들어가 있다.)
 - 핵심 구조
 
		Collection ─┬── List ──────┬── ArrayList
					│	     	   ├── LinkedList
					│	 		   └── Vector
					│
				    └── Set ────────── HashSet
				   			  
		Map ───────────────────────┬── HashMap 	
			   					   ├── SortedMap ─── TreeMap
			   	   				   └── HashTable 
1.2 주요 인터페이스 분류
 - List
	1) 순서가 있는 데이터의 집합
	2) 중복 저장 허용
 - Set
	1) 순서가 없는 데이터의 집합
	2) 중복 저장 불가
 - Map
	1) 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터
	2) 순서가 없는 데이터의 집합
	3) 키(key)는 중복 저장 불가
	4) 값(value)는 중복 저장 허용
	
 - 반복자 (Iterator)를 사용할 수 있다.
 	1) Iterator 메소드
 		(1) hasNext()	: 다음 요소에 읽어 올 요소가 있는지 확인하는 메소드
 						  있으면 true 없으면 false 반환.
		(2) next()		: 다음 요소를 가져온다.
		(3) remove()	: next()로 읽어온 요소를 삭제한다.
		
		
		List<String> list = new ArrayList<>();
		Iterator itr = list.iterator();				// itr : 컬렉션의 요소를 꺼낼 수 있다.
		
		while(itr.hasNext()){
			itr.next();
		} 		


1.3 구현 클래스 
 <List>
 - ArrayList
	1. 객체(인스턴스)를 여러 개 저장할 수 있는 '배열'을 구현한 컬렉션이다.
	2. 가장 많이 사용하는 컬렉션이다.
	3. 기존엔 Vector를 많이 사용했다.(Vector는 ArrayList와 내부 구조가 같지만 멀티 스레드 지원x)
	4. 장점 
		1) 구조가 단순하다.
		2) 읽어 들이는 속도가 빠르다. (순차적일 때)
		3) 저장된 객체의 변화가 적은 경우에 사용하는 것이 좋다. (이미 저장된 것은 변화가 적다.)
	5. 단점
		1) 일단 만들고 나면 나중에 크기 변경이 어렵다.
		2) 처음부터 크게 만들면 공간 낭비가 생긴다.	
		3) 비순차적 접근이 느리다.	
		4) 데이터의 중간 위치에 추가/제거가 어렵다. (<-> LinkedList : 추가/제거가 쉽다.)
			
 - LinkedList
 	1. ArrayList와 사용방법은 같지만 내부 구조가 다르다.
	1. 자신과 연결된 다음 요소에 대한 참조(다음 데이터의 위치) + 데이터로 구성된다.
	2. 비연속적인 공간을 사용한다.
	3. 장점
		1) 추가/제거 작업이 빠르다.
		2) 잦은 추가/제거가 발생되는 경우에 사용한다.
	4. 단점 
		1) 순차적인 순회가 느리다.
		2) 구현이 어렵고, 오류가 발생할 가능성이 있다.	 		

 <Set>	
 - HashSet
	1. Set 인터페이스를 구현한 대표적인 클래스이다.
	2. 중복된 데이터는 저장되지 않는다.
	3. 중복된 데이터 판단 원리
		1) hashCode() 확인 
			(1) 값이 같으면 equals() 호출해서 동등 비교
			(2) 값이 다르면 다른 데이터로 판단
		2) equals() 확인 (값이 같을 때)
	4. 사용자가 정의한 객체(인스턴스)를 저장하려면 hashCode(), equals()를 오버라이드 해야 한다.
	5. 저장 순서가 없다.	(add 한 순서대로 유지되지 않는다.)
	6. add 한 순서를 유지하려면 LinkedHashSet 클래스를 사용한다.
	
 - TreeSet
 	1. 이진 탐색 트리(BinarySearchTree)의 형태로 데이터를 저장.
 	2. 데이터의 추가/삭제 시간이 걸리지만 검색과 정렬이 뛰어난 장점
 	3. 중복된 데이터는 저장되지 않는다.
 
 <Map>
 - HashMap
	1. 해시 코드를 사용하는 M	ap이다.(많은 양의 자료에 적합하다.)
	2. 키(key)와 값(value)의 조합으로 데이터를 저장한다.
	3. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다.
	4. 기존 저장된 키와 동일한 키로 값을 저장하면 새로운 값을 덮어쓴다.
	5. HashTable과 동일한 구조를 가지고 있지만 멀티 스레드로 동시에 실행할 수 없다.

	
	
	
	